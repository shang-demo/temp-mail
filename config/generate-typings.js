'use strict';
const Promise = require('bluebird');
const path = require('path');
const fs = Promise.promisifyAll(require('fs'));

const projectPath = path.join(__dirname, '../');
const serverPath = path.join(projectPath, 'src');
const autoGenerateDir = path.join(projectPath, 'config/typings/');
const autoGeneratePath = path.join(projectPath, 'config/typings/shang-auto-generate.d.ts');

const ideaPath = path.join(projectPath, '.idea');
const jsLibraryMappingsXmlPath = path.join(ideaPath, 'jsLibraryMappings.xml');
const jsLibraryMappingsXmlLocalDataPath = path.join(__dirname, 'data/jsLibraryMappings.xml');
const librariesPath = path.join(ideaPath, 'libraries');
const librariesLocalDataPath = path.join(__dirname, 'data/libraries/shang_auto_generate.xml');
const librariesName = 'shang_auto_generate.xml';

function filePathOneLayer(modelsPath) {
  return Promise
    .try(function () {
      return fs.readdirAsync(modelsPath);
    })
    .then(function (fileNames) {
      return Promise.map(fileNames, function (fileName) {
        var filePath = path.join(modelsPath, fileName);

        var extname = path.extname(filePath);
        if (extname !== '.js') {
          return null;
        }

        return fs.statAsync(filePath)
          .then(function (stat) {
            return {
              basename: fileName.replace(/\.js/i, ''),
              name: fileName,
              path: filePath,
              stat: stat
            };
          });
      })
        .filter(function (file) {
          return file && file.stat && file.stat.isFile();
        });
    });
}

function ensureTypingDir() {
  return fs.mkdirAsync(autoGenerateDir)
    .catch(function (e) {
      if (e.code === 'EEXIST') {
        return Promise.resolve();
      }
      return Promise.reject(e);
    });
}

function getServicesDeclare() {
  return filePathOneLayer(path.join(serverPath, 'services'))
    .map(function (serviceFile) {
      return 'declare let ' + serviceFile.basename + ' = global.' + serviceFile.basename + ';';
    }).then(function (arr) {
      return arr.join('\n');
    });
}

function getModelsDeclare() {
  return filePathOneLayer(path.join(serverPath, 'models'))
    .map(function (modelFile) {
      return 'declare let ' + modelFile.basename + ' = require(\'mongoose\').Model;';
    }).then(function (arr) {
      return arr.join('\n');
    });
}

function getGlobal() {
  return Promise
    .try(function () {
      return 'declare let _ = require(\'lodash\');\ndeclare let Promise = require(\'bluebird\');\n';
    });
}

function getErrors() {
  let errors = require(path.join(serverPath, 'config/errors')).errors;
  let str = 'let Errors: {\n  OperationalError(): void,';

  return Promise
    .map(Object.keys(errors), function (key) {
      return '  ' + key + '(extra?: object, message?: string): Error,';
    })
    .then(function (arr) {
      return str + '\n' + arr.join('\n') + '\n}\ndeclare let Errors: Errors;';
    });
}

function getMKoa() {
  return Promise
    .try(function () {
      return '\ndeclare let mKoa = {\n  config: require(\'config\'),\n  environment: {}\n};\n';
    });
}

function globalLogger() {
  return Promise
    .try(function () {
      return 'declare let logger = require(\'pino\')();';
    });
}

function init() {
  return ensureTypingDir()
    .then(function () {
      return Promise
        .all([
          getGlobal(),
          getErrors(),
          globalLogger(),
          getModelsDeclare(),
          getServicesDeclare(),
          getMKoa()
        ]);
    })
    .then(function (arr) {
      return fs.writeFileAsync(autoGeneratePath, arr.join('\n'));
    })
    .then(function () {
      return replaceJsLibraryMappings();
    });
}

function addToIml(file) {
  var str = `<orderEntry type="library" name="shang-auto-generate" level="project" />`;

  return fs.readFileAsync(file.path)
    .then(function (buffer) {
      var data = buffer.toString();
      data = data.replace(str, '');
      data = data.replace('</component>', `  ${str}\n  </component>`);

      return fs.writeFileAsync(file.path, data);
    });
}

function replaceJsLibraryMappings() {
  return Promise
    .try(() => {
      return fs.readFileAsync(jsLibraryMappingsXmlPath)
        .catch(function (e) {
          return fs.readFileAsync(jsLibraryMappingsXmlLocalDataPath);
        });
    })
    .then(function (buffer) {
      var data = buffer.toString();
      data = data.replace(/\s*<file url="file:\/\/\$PROJECT_DIR\$\/src" libraries="{shang-auto-generate}" \/>\n/g, '');
      data = data.replace(/,\s*shang-auto-generate/gi, '');
      data = data.replace(`<component name="JavaScriptLibraryMappings">`, `<component name="JavaScriptLibraryMappings">\n    <file url="file://$PROJECT_DIR$/src" libraries="{shang-auto-generate}" />\n`);
      return fs.writeFileAsync(jsLibraryMappingsXmlPath, data);
    })
    .then(function () {
      return fs.mkdirAsync(librariesPath)
        .catch(function () {
        });
    })
    .then(function () {
      return fs.readFileAsync(librariesLocalDataPath);
    })
    .then(function (data) {
      return fs.writeFileAsync(path.join(librariesPath, librariesName), data);
    })
    .then(function () {
      return getNameMatchPath(ideaPath, /\.iml$/);
    })
    .then(function (file) {
      return addToIml(file);
    });
}

function getNameMatchPath(rootPath, reg) {
  return Promise
    .try(() => {
      return fs.readdirAsync(rootPath);
    })
    .map((fileName) => {
      let filePath = path.join(rootPath, fileName);

      return fs
        .lstatAsync(filePath)
        .then((stats) => {
          return {
            basename: fileName.replace(/\.js/i, ''),
            name: fileName,
            path: filePath,
            stats,
          };
        });
    })
    .filter((file) => {
      return file.stats && file.stats.isFile() && reg.test(file.name);
    })
    .then(function (arr) {
      return arr[0];
    });
}

if (process.argv && process.argv[2] && process.argv[2] === 'init') {
  init();
}

module.exports = {
  init,
};
